name: CI/CD Pipeline

env:
  ECR_REGISTRY: 272007598366.dkr.ecr.eu-central-1.amazonaws.com

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy to environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

jobs:
  # Build and test (runs on all pushes and PRs)
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    concurrency:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Type check
        run: npm run typecheck

      - name: Run linter
        run: npm run lint

      - name: Run unit tests
        env:
          DATABASE_URL: "postgresql://dummy:dummy@localhost:5432/dummy"
          NEXTAUTH_SECRET: "dummy-secret-for-build-long-enough-32-chars-!!"
          SKIP_ENV_VALIDATION: 1
        run: npm test

      - name: Build application
        env:
          DATABASE_URL: "postgresql://dummy:dummy@localhost:5432/dummy"
          NEXTAUTH_SECRET: "dummy-secret-for-build-long-enough-32-chars-!!"
          NEXTAUTH_URL: "http://localhost:3000"
          SKIP_ENV_VALIDATION: 1
        run: npm run build

      - name: Security audit
        run: npm audit --audit-level=critical || echo "‚ö†Ô∏è Audit found vulnerabilities ‚Äî review before production deploy"

      # ECR Integration: Build and push Docker image (skip on PRs to save ECR storage)
      - name: Configure AWS credentials
        if: github.event_name != 'pull_request'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Login to Amazon ECR
        if: github.event_name != 'pull_request'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set app version for build
        if: github.event_name != 'pull_request'
        id: app_version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          else
            echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
          fi
          echo "Using NEXT_PUBLIC_APP_VERSION=${{ steps.app_version.outputs.version }}"

      - name: Extract metadata
        if: github.event_name != 'pull_request'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/daatan-app
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
            type=raw,value=staging-latest,enable={{is_default_branch}}

      - name: Build and push to ECR
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_APP_VERSION=${{ steps.app_version.outputs.version }}
            DATABASE_URL=postgresql://placeholder
            NEXTAUTH_URL=https://daatan.com
            NEXT_PUBLIC_ENV=production

  # Deploy to STAGING (on push to main)
  deploy-staging:
    name: Deploy to Staging
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    concurrency:
      group: deploy-staging
      cancel-in-progress: false
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Check Instance SSM Health
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=daatan-backend" "Name=tag:Environment,Values=staging" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          PING_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query "InstanceInformationList[0].PingStatus" \
            --output text)
            
          echo "Instance $INSTANCE_ID PingStatus: $PING_STATUS"
          if [[ "$PING_STATUS" != "Online" ]]; then
            echo "‚ùå Error: Instance is $PING_STATUS. SSM command will fail. Please check or reboot the instance."
            exit 1
          fi

      - name: Deploy to Staging (SSM)
        run: |
          # Get Instance ID
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=daatan-backend" "Name=tag:Environment,Values=staging" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "Found Staging Instance: $INSTANCE_ID"

          # Encode scripts and nginx config (nginx must be deployed so /api/auth/ pass-through is live)
          BLUE_GREEN_SCRIPT=$(base64 -w 0 scripts/blue-green-deploy.sh)
          VERIFY_HEALTH_SCRIPT=$(base64 -w 0 scripts/verify-health.sh)
          VERIFY_LOGS_SCRIPT=$(base64 -w 0 scripts/verify-logs.sh)
          VERIFY_DEPLOY_SCRIPT=$(base64 -w 0 scripts/verify-deploy.sh)
          VERIFY_AUTH_SERVER_SCRIPT=$(base64 -w 0 scripts/verify-auth-server.sh)
          COMPOSE_FILE=$(base64 -w 0 docker-compose.prod.yml)
          NGINX_CONF=$(base64 -w 0 nginx-ssl.conf)
          
          # Construct the shell script to run on EC2
          SDK_SCRIPT_CONTENT="
          set -e
          export HOME=/home/ubuntu
          export PATH=\$PATH:/usr/local/bin:/usr/bin
          
          echo 'üìÇ Setting up deployment directories...'
          mkdir -p ~/app/scripts
          cd ~/app
          
          echo 'üìÑ Writing docker-compose.prod.yml...'
          echo \"$COMPOSE_FILE\" | base64 -d > docker-compose.prod.yml
          
          echo 'üìÑ Writing nginx-ssl.conf...'
          echo \"$NGINX_CONF\" | base64 -d > nginx-ssl.conf
          
          echo 'üìú Writing blue-green-deploy.sh...'
          echo \"$BLUE_GREEN_SCRIPT\" | base64 -d > scripts/blue-green-deploy.sh
          
          echo 'üîç Writing verify scripts...'
          echo \"$VERIFY_HEALTH_SCRIPT\" | base64 -d > scripts/verify-health.sh
          echo \"$VERIFY_LOGS_SCRIPT\" | base64 -d > scripts/verify-logs.sh
          echo \"$VERIFY_DEPLOY_SCRIPT\" | base64 -d > scripts/verify-deploy.sh
          echo \"$VERIFY_AUTH_SERVER_SCRIPT\" | base64 -d > scripts/verify-auth-server.sh
          
          chmod +x scripts/*.sh
          
          echo 'üîÑ Reloading nginx to apply config...'
          docker compose -f docker-compose.prod.yml exec -T nginx nginx -s reload 2>/dev/null || true
          
          echo 'üîê Logging in to ECR (Region: eu-central-1)...'
          aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin $ECR_REGISTRY
          
          echo '‚¨áÔ∏è Pulling staging image...'
          docker pull $ECR_REGISTRY/daatan-app:staging-latest
          
          echo 'üè∑Ô∏è Tagging image...'
          docker tag $ECR_REGISTRY/daatan-app:staging-latest daatan-app:staging-latest
          
          echo 'üöÄ Executing blue-green deployment...'
          export GIT_COMMIT=\"${{ github.sha }}\"
          export SKIP_BUILD=true
          ./scripts/blue-green-deploy.sh staging
          "
          
          # Encode the entire shell script content to avoid JSON escaping issues
          B64_SDK_SCRIPT=$(echo "$SDK_SCRIPT_CONTENT" | base64 -w 0)
          
          echo "üöÄ Sending SSM Command..."
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=instanceids,Values=$INSTANCE_ID" \
            --comment "Deploy Staging ${{ github.sha }}" \
            --parameters commands="[\"echo $B64_SDK_SCRIPT | base64 -d | bash\"]" \
            --output text \
            --query "Command.CommandId")
            
          echo "‚úÖ Command sent. ID: $COMMAND_ID"
          
          echo '‚è≥ Waiting for command execution (Timeout: 10m)...'
          START_TIME=$(date +%s)
          while true; do
            STATUS=$(aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --query "CommandInvocations[0].Status" --output text)
            echo "Status: $STATUS"
            if [[ "$STATUS" == "Success" ]]; then
              echo "‚úÖ Deployment successful!"
              break
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "‚ùå Deployment failed!"
              aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --query "CommandInvocations[0].CommandPlugins[0].Output" --output text
               exit 1
            fi

            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            if [[ $ELAPSED -gt 600 ]]; then
              echo "‚ùå Deployment timed out after 10 minutes!"
              exit 1
            fi

            sleep 10
          done

      - name: Verify staging site (External)
        run: |
          sleep 5
          ./scripts/verify-health.sh "https://staging.daatan.com"

  # Deploy to PRODUCTION (on tag push only)
  deploy-production:
    name: Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    concurrency:
      group: deploy-production
      cancel-in-progress: false
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Get version from tag
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            echo "version=${VERSION#v}" >> $GITHUB_OUTPUT
          else
            echo "version=manual" >> $GITHUB_OUTPUT
          fi

      - name: Check Instance SSM Health
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=daatan-backend" "Name=tag:Environment,Values=prod" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          PING_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query "InstanceInformationList[0].PingStatus" \
            --output text)
            
          echo "Instance $INSTANCE_ID PingStatus: $PING_STATUS"
          if [[ "$PING_STATUS" != "Online" ]]; then
            echo "‚ùå Error: Instance is $PING_STATUS. SSM command will fail. Please check or reboot the instance."
            exit 1
          fi

      - name: Deploy to Production (SSM)
        run: |
          # Get Instance ID (Note: Tag Value is 'prod')
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=daatan-backend" "Name=tag:Environment,Values=prod" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "Found Production Instance: $INSTANCE_ID"

          # Determine Image Tag
          if [[ "${{ steps.version.outputs.version }}" != "manual" ]]; then
            IMAGE_TAG="${{ steps.version.outputs.version }}"
          else
            IMAGE_TAG="staging-latest"
          fi
          echo "Deploying Image Tag: $IMAGE_TAG"

          # Encode scripts and nginx config (nginx must be deployed so /api/auth/ pass-through is live)
          BLUE_GREEN_SCRIPT=$(base64 -w 0 scripts/blue-green-deploy.sh)
          VERIFY_HEALTH_SCRIPT=$(base64 -w 0 scripts/verify-health.sh)
          VERIFY_LOGS_SCRIPT=$(base64 -w 0 scripts/verify-logs.sh)
          VERIFY_DEPLOY_SCRIPT=$(base64 -w 0 scripts/verify-deploy.sh)
          VERIFY_AUTH_SERVER_SCRIPT=$(base64 -w 0 scripts/verify-auth-server.sh)
          COMPOSE_FILE=$(base64 -w 0 docker-compose.prod.yml)
          NGINX_CONF=$(base64 -w 0 nginx-ssl.conf)
          
          # Construct the shell script to run on EC2
          SDK_SCRIPT_CONTENT="
          set -e
          export HOME=/home/ubuntu
          export PATH=\$PATH:/usr/local/bin:/usr/bin
          
          echo 'üìÇ Setting up deployment directories...'
          mkdir -p ~/app/scripts
          cd ~/app
          
          echo 'üìÑ Writing docker-compose.prod.yml...'
          echo \"$COMPOSE_FILE\" | base64 -d > docker-compose.prod.yml
          
          echo 'üìÑ Writing nginx-ssl.conf...'
          echo \"$NGINX_CONF\" | base64 -d > nginx-ssl.conf
          
          echo 'üìú Writing blue-green-deploy.sh...'
          echo \"$BLUE_GREEN_SCRIPT\" | base64 -d > scripts/blue-green-deploy.sh
          
          echo 'üîç Writing verify scripts...'
          echo \"$VERIFY_HEALTH_SCRIPT\" | base64 -d > scripts/verify-health.sh
          echo \"$VERIFY_LOGS_SCRIPT\" | base64 -d > scripts/verify-logs.sh
          echo \"$VERIFY_DEPLOY_SCRIPT\" | base64 -d > scripts/verify-deploy.sh
          echo \"$VERIFY_AUTH_SERVER_SCRIPT\" | base64 -d > scripts/verify-auth-server.sh
          
          chmod +x scripts/*.sh
          
          echo 'üîÑ Reloading nginx to apply config...'
          docker compose -f docker-compose.prod.yml exec -T nginx nginx -s reload 2>/dev/null || true
          
          echo 'üîê Logging in to ECR (Region: eu-central-1)...'
          aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin $ECR_REGISTRY
          
          echo \"‚¨áÔ∏è Pulling production image (tag: $IMAGE_TAG)...\"
          docker pull $ECR_REGISTRY/daatan-app:$IMAGE_TAG
          
          echo 'üè∑Ô∏è Tagging image as latest...'
          docker tag $ECR_REGISTRY/daatan-app:$IMAGE_TAG daatan-app:latest
          
          echo 'üöÄ Executing blue-green deployment...'
          export GIT_COMMIT=\"${{ github.sha }}\"
          export SKIP_BUILD=true
          ./scripts/blue-green-deploy.sh production
          "
          
          # Encode the entire shell script content to avoid JSON escaping issues
          B64_SDK_SCRIPT=$(echo "$SDK_SCRIPT_CONTENT" | base64 -w 0)
          
          echo "üöÄ Sending SSM Command..."
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=instanceids,Values=$INSTANCE_ID" \
            --comment "Deploy Production ${{ steps.version.outputs.version }}" \
            --parameters commands="[\"echo $B64_SDK_SCRIPT | base64 -d | bash\"]" \
            --output text \
            --query "Command.CommandId")
            
          echo "‚úÖ Command sent. ID: $COMMAND_ID"
          
          echo '‚è≥ Waiting for command execution (Timeout: 10m)...'
          START_TIME=$(date +%s)
          while true; do
            STATUS=$(aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --query "CommandInvocations[0].Status" --output text)
            echo "Status: $STATUS"
            if [[ "$STATUS" == "Success" ]]; then
              echo "‚úÖ Deployment successful!"
              break
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "‚ùå Deployment failed!"
              aws ssm list-command-invocations --command-id "$COMMAND_ID" --details --query "CommandInvocations[0].CommandPlugins[0].Output" --output text
               exit 1
            fi

            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            if [[ $ELAPSED -gt 600 ]]; then
              echo "‚ùå Deployment timed out after 10 minutes!"
              exit 1
            fi

            sleep 10
          done

      - name: Verify production site
        run: |
          sleep 5
          ./scripts/verify-health.sh "https://daatan.com"